---
title: "proyecto_contingencias"
author: "Alejandro Brenes - C21319, Santiago Fernández - C22943, Félix Madrigal -
  C24459 y Eyeri Méndez - C24765"
date: "`r Sys.Date()`"
output:
  rmdformats::robobook:
    number_sections: TRUE
---

# Proyecto Contingencias de Vida I

## Librerías necesarias

```{r librerías}
pacman::p_load(readxl,
               ggplot2,
               dplyr,
               data.table)
```

## Funciones necesarias

Se crea una función que extrae la probabilidad de que un individuo sobreviva k años.

```{r fun_kpx}
#' Calcula la probabilidad de sobrevivencia de un individuo.
#'
#' Esta función calcula la probabilidad de sobrevivencia de un individuo de 
#' de edad \code{x}, con base a la cantidad de años \code{k}, iniciando en el
#' año 2024, con una \code{tabla} de mortalidad dada.
#'
#' @param x (Integer) Edad en años cumplidos del individuo.
#' @param k (Integer) Cantidad de años de sobrevivencia.
#' @param tabla (DataFrame) Tabla de mortalidad con las probabilidades de muerte.
#'
#' @return (Numeric) Probabilidad de que el individuo sobreviva k años.
#'
calcular.kpx <- function(x, k, tabla){
  
  if (k > 0){
    kpx <- prod(sapply(0:(k-1), function(i) 1-tabla[[x + i + 1, 26 + i]]))
  }
  else {
    kpx <- 1
  }
  return(kpx)
}
```

Seguro temporal.

```{r seguro_temporal}
#' Calcula la esperanza del valor presente de un seguro temporal.
#'
#' Esta función calcula la esperanza del valor presente de un seguro temporal 
#' para un asegurado de edad \code{x}, con base al año actual \code{y} y con una 
#' duración del seguro de \code{n} años. Utiliza una tabla de mortalidad 
#' específica y una tasa de interés dada.
#'
#' @param x (Integer) Edad en años cumplidos del asegurado.
#' @param y (Integer) Año actual.
#' @param n (Integer) Duración del seguro en años.
#' @param qx (DataFrame) Tabla de mortalidad con las probabilidades de muerte.
#' @param w (Integer) Edad final para el cálculo.
#' @param i (Numeric) Tasa de interés anual.
#'
#' @return (Numeric) La esperanza del valor presente del seguro temporal.
#'
Axn <- function(x, y, n, qx, w, i){
    
  # Calcula cada factor de descuento en forma de vector
  v <- ((1.03) / (1 + i)) ^ c(1:(min((w - x), n))) 
  
  # Obtiene los tqx (t=1) de forma diagonal
  tqx <- sapply(0:min((n - 1), (w - x)), function(j) as.numeric(qx[x + 1 + j,  y - 1998 + j]))

  # Calcula los tpx a partir de los tqx de forma acumulativa
  tpx <- c(1, cumprod(1 - tqx))[-length(c(1, cumprod(1 - tqx)))]

  # Calcula la esperanza de manera vectorizada
  return(sum(v * tqx * tpx))
}
```

Seguro completo.

```{r seguro_completo}
#' Calcula la esperanza del valor presente de un seguro completo.
#'
#' Esta función calcula la esperanza del valor presente de un seguro completo 
#' para un asegurado de edad \code{x}, con base al año actual \code{y} y con una 
#' duración del seguro de \code{n} años. Utiliza una tabla de mortalidad 
#' específica y una tasa de interés dada.
#'
#' @param x (Integer) Edad en años cumplidos del asegurado.
#' @param y (Integer) Año actual.
#' @param n (Integer) Duración del seguro en años.
#' @param qx (DataFrame) Tabla de mortalidad con las probabilidades de muerte.
#' @param w (Integer) Edad final para el cálculo.
#' @param i (Numeric) Tasa de interés anual.
#'
#' @return (Numeric) La esperanza del valor presente del seguro completo.
#'
Ax <- function(x, y, qx, w, i){
  
  # Guardamos el valor presente como vector
  v <- ((1.03) / (1 + i)) ^ c(1:(min((w - x), (ncol(qx) - y + 1999))))
  
  # Guardamos la diagonal que se requiere de los tqx, estos son: qx, qx+1, ...
  qx <- sapply(1:min((ncol(qx) - y + 1999), (w - x)), function(j) as.numeric(qx[x + j,  y - 1999 + j]))
  
  # Obtenemos los tpx necesarios, estos son: 0px, 1px, ...
  tpx <- c(1, cumprod(1 - qx))
  
  # Realizamos la operación necesaria
  return(sum(v * qx * tpx[-length(tpx)]))
}
```

Seguro dotal.

```{r seguro_dotal}
#' Calcula la esperanza del valor presente de un seguro dotal.
#'
#' Esta función calcula la esperanza del valor presente de un seguro dotal 
#' para un asegurado de edad \code{x}, con base al año actual \code{y} y con una 
#' duración del seguro de \code{n} años. Utiliza una tabla de mortalidad 
#' específica y una tasa de interés dada.
#'
#' @param x (Integer) Edad en años cumplidos del asegurado.
#' @param y (Integer) Año actual.
#' @param n (Integer) Duración del seguro en años.
#' @param qx (DataFrame) Tabla de mortalidad con las probabilidades de muerte.
#' @param w (Integer) Edad final para el cálculo.
#' @param i (Numeric) Tasa de interés anual.
#'
#' @return (Numeric) La esperanza del valor presente del seguro dotal.
#'
dotal <- function(x, y, n, qx, w, i){
  
  # Seguro temporal
  temporal <- Axn(x, y, n, qx, w, i)
  
  # Probabilidades de muerte y de sobrevivencia
  tqx <- sapply(0:min((n - 1), (w - x)), function(j) as.numeric(qx[x + 1 + j,  y - 1998 + j]))
  tpx <- c(1, cumprod(1 - tqx))
  
  # Seguro dotal puro, se usa la última probabilidad de tpx
  dotal_puro <- (((1.03) / (1 + i)) ^ n) * tpx[length(tpx)]
  
  return((temporal + dotal_puro))
}
```

Se creará una función para identificar el primer *False* de cada fila de una matriz.

```{r fun_false}
fila.muerte <- function(fila){
  #' Función que devuelve el índice de un vector una posición antes de un falso.
  #'
  #' Calcula el índice de la \code{fila} de una matriz una posición antes de que
  #' el individuo fallezca.
  #'
  #' @param fila (Numeric) Vector o fila de una matriz de booleanos o de 1 y 0.
  #'
  #' @return (Numeric) Índice, una posición antes, de donde se encuentre un
  #' falso.
  #'
  fila[(which(!fila)[1] + 1):length(fila)] <- FALSE
  return(fila)
}
```

## Descarga de datos

Se inicia con la descarga de los datos, para la base de datos de los empleados se agregaron columnas con la edad y el año de nacimiento, para los valores tqx se realizó una tabla dinámica separada por cada sexo, todos los cambios fueron hechos desde MS Excel.

```{r descarga_datos}
empleados <- read_excel("datos/Base de datos.xlsx")

qx.hombres <- read_excel("datos/tavid2000-2150.xlsx", sheet = "Sexo_1_limpio")

qx.mujeres <- read_excel("datos/tavid2000-2150.xlsx", sheet = "Sexo_2_limpio")
```

Se cambia el nombre y el orden las columnas de la base de empleados.

```{r corr_columnas}

# Se renombran las columnas
empleados <- empleados %>% 
  rename(
    id = "Número de empleado",
    fecha_nac = "Fecha de nacimiento",
    sexo = Sexo,
    edad = Edad,
    anno_nac = Anno_nac
  )

# Se reordena el DataFrame
empleados <- empleados %>%
  dplyr::select(id, sexo, edad, anno_nac, fecha_nac)
```

La edad de las personas se calculó para 2023, se requiere la de 2024, por los que se suma una unidad a esa columna.

```{r corr_edad}
empleados$edad <- empleados$edad + 1
```

## Modelo determinístico

### Proyección demográfica de población de empleados activos

Se creará una función para determinar los empleados activos que continúan vivos cada año por sexo.

```{r fun_activos_vivos}
# La siguiente funcion recibe el DataFrame de los empleados (df.empleados), el DataFrame de probabilidades de muertes por sexo (df.muertes) y el sexo a calcular su proyección (sexo). Es importante que el sexo coincida con el sexo de las probabilidades de muerte, de lo contrario, podría conducir a errores en el cálculo. Se devuelve una lista con: un DataFrame con la población activa que sigue viva por cada año y la matriz de sobrevivientes por edad
pob.activos <- function(df.empleados, df.muertes, sexo) {
  # Se filtra el DataFrame por el sexo
  if (sexo == "M") {
    df.empleados <- df.empleados %>%
      filter(sexo == "M")
  }
  else if (sexo == "F") {
    df.empleados <- df.empleados %>%
      filter(sexo == "F")
  }
  else{
    return("El sexo del parámetro no fue encontrado")
  }
  
  # Las edades de las personas que nos interesan para el estudio
  edades <- c(min(df.empleados$edad):65)
  
  # Contamos la cantidad de personas que hay por cada edad
  num.personas <- as.vector(table(as.factor(df.empleados$edad)))
  
  # Lista para guardar las probabilidades de sobrevivencia
  lista.tpx <- list()
  
  # Se itera para obtener las probabilidades de sobrevivencia de cada edad
  for (edad in edades) {
    # Se obtiene un vector de qx de forma diagonal
    tqx <-
      sapply(0:(65 - edad), function(j)
        as.numeric(df.muertes[edad + 1 + j,  26 + j]))
    
    # Calcula los tpx a partir de los tqx de forma acumulativa
    tpx <-
      c(1, sapply(1:(length(tqx)), function(k)
        prod(1 - tqx[1:k])))
    
    # La longitud de los tpx va disminuyendo, por lo que calculamos los 0 necesarios para formar una matriz posteriormente
    if ((48 - length(tpx)) > 0) {
      tpx <- c(tpx, rep(0, (48 - length(tpx))))
    }
    
    lista.tpx[[(edad - 20)]] <- tpx
  }
  
  # Con todos los vectores en una lista, creamos la matriz, en donde cada fila es la probabilidad de sobrevivencia de una persona de edad x
  matriz.prob <- do.call(rbind, lista.tpx)
  
  # Se realiza la multiplicación de personas por su probabilidad de sobrevivencia
  matriz.final <- num.personas * matriz.prob
  
  # Se crea un dataframe con la cantidad de personas restantes por año, para esto se sumarán las columnas de la matriz anterior
  df.resultado <-
    data.frame(anno = c(2023:(2091 - min(edades))),
               # 2024 + 65 + 1 - min(edades)
               trabajadores = colSums(matriz.final))
  
  # Se devolverá una lista, primero tendrá el resultado en DataFrame y posteriormente tendrá la matriz que indica cuántas personas se pensionarion cada año
  lista.res <- list(df.resultado, matriz.final)
  
  return(lista.res)
}
```

Se guardan las proyecciones demográficas para hombres y mujeres.

```{r act_vivos}
# Hombres activos vivos
activos.vivosh <- pob.activos(empleados, qx.hombres, "M")

# Mujeres activas vivas
activos.vivosm <- pob.activos(empleados, qx.mujeres, "F")
```

### Proyección demográfica de defunciones de empleados activos

Se procede a crear la función de muertes de empleados activos cada año.

```{r fun_activos_muertos}
# La siguiente funcion recibe el DataFrame de los empleados (df.empleados), el DataFrame de probabilidades de muertes por sexo (df.muertes) y el sexo a calcular su proyección (sexo). Es importante que el sexo coincida con el sexo de las probabilidades de muerte, de lo contrario, podría conducir a errores en el cálculo. Se devuelve una lista con: un DataFrame con los fallecidos por cada año y la matriz de fallecidos por edad
def.activos <- function(df.empleados, df.muertes, sexo) {
  # Se filtra el DataFrame por el sexo
  if (sexo == "M") {
    df.empleados <- df.empleados %>%
      filter(sexo == "M")
  }
  else if (sexo == "F") {
    df.empleados <- df.empleados %>%
      filter(sexo == "F")
  }
  else{
    return("El sexo del parámetro no fue encontrado")
  }
  
  # Las edades de las personas que nos interesan para el estudio
  edades <- c(min(df.empleados$edad):65)
  
  # Contamos la cantidad de personas que hay por cada edad
  num.personas <- as.vector(table(as.factor(df.empleados$edad)))
  
  # Lista para guardar las probabilidades de sobrevivencia
  lista.tqx <- list()
  
  # Se itera para obtener las probabilidades de sobrevivencia de cada edad
  for (edad in edades) {
    # Se obtiene un vector de qx de forma diagonal
    qx <-
      sapply(0:(65 - edad), function(j)
        as.numeric(df.muertes[edad + 1 + j,  26 + j]))
    
    # Calcula los tpx a partir de los tqx de forma acumulativa
    tpx <-
      sapply(1:(length(qx)), function(k)
        prod(1 - qx[1:k]))
    
    # Calcula los t|qx a partir de los qx y los tpx de forma acumulativa
    
    if (length(qx) == 1) {
      c(0, qx[1])
    }
    else{
      tqx <-
        c(0, qx[1], sapply(2:(length(qx)), function(l)
          (tpx[(l - 1)] * qx[l])))
    }
    
    # La longitud de los tqx va disminuyendo, por lo que calculamos los 0 necesarios para formar una matriz posteriormente
    if ((48 - length(tqx)) > 0) {
      tqx <- c(tqx, rep(0, (48 - length(tqx))))
    }
    
    lista.tqx[[(edad - 20)]] <- tqx
  }
  
  # Con todos los vectores en una lista, creamos la matriz, en donde cada fila es la probabilidad de sobrevivencia de una persona de edad x
  matriz.prob <-
    matrix(unlist(lista.tqx),
           nrow = length(lista.tqx),
           byrow = TRUE)
  
  # Se realiza la multiplicación de personas por su probabilidad de muerte
  matriz.final <- as.vector(num.personas) * as.matrix(matriz.prob)
  
  # Se crea un dataframe con la cantidad de personas restantes por año, para esto se sumarán las columnas de la matriz anterior
  df.resultado <-
    data.frame(anno = c(2023:(2091 - min(edades))),
               # 2024 + 65 + 2 - min(edades)
               trabajadores = colSums(matriz.final))
  
  # Se devolverá una lista, primero tendrá el resultado en DataFrame y posteriormente tendrá la matriz que indica cuántas personas se pensionarion cada año
  lista.res <- list(df.resultado, matriz.final)
  
  return(lista.res)
}
```

Se guardan los empleados activos fallecidos durante cada año (se comprueba que son los valores correctos al sumar los valores de la segunda columna del DataFrame de las funciones de empleados activos).

```{r act_muertos}
# Hombres activos fallecidos
activos.fallecidosh <- def.activos(empleados, qx.hombres, "M")

# Mujeres activas fallecidas
activos.fallecidosm <- def.activos(empleados, qx.mujeres, "F")
```

### Proyección demográfica de pensionados

Primeramente se determinarán los pensionados que entran cada año para cada sexo, usando lo hecho en el punto a).

```{r pensionados_por_anno}

# Se extraen las matrices de sobrevivientes por edad para cada sexo
matriz.hombres <- activos.vivosh[[2]]
matriz.mujeres <- activos.vivosm[[2]]

# Función para obtener las entradas de una matriz que tengan a su derecha una entrada igual a 0 (en nuestro contexto, las personas pensionadas)
personas.pensionadas <- function(matriz) {
  
  copia = copy(matriz)
  
  # Se encuentran las posiciones donde el valor a la derecha es igual a 0
  posiciones <- which(copia[, -ncol(copia)] != 0 & copia[, -1] == 0, arr.ind = TRUE)
  
  # Luego se extraen los valores de la matriz en esas posiciones
  valores <- copia[posiciones]
  
  return(valores)
  
}

# Se crean los años donde entran pensionados
anno <- c(2024:2068)

# Se extraen los pensionados hombres usando la función anterior
pensionados <- c(personas.pensionadas(matriz.hombres))

# Se crea el dataframe de pensionados hombres que entran por año
df.pensionadosh <- data.frame(anno = anno, pensionados = pensionados)

# Se extraen las pensionadas mujeres usando la función anterior
pensionados <- c(personas.pensionadas(matriz.mujeres))

# Se crea el dataframe de pensionadas mujeres que entran por año
df.pensionadosm <- data.frame(anno = anno, pensionados = pensionados)

```

Posteriormente se crea la función para determinar los pensionados que continúan vivos cada año por sexo.

```{r fun_pensionados_vivos}

# Función que recibe el DataFrame de los pensionados por sexo (df.pensionados) y el DataFrame de probabilidades de muertes por sexo (df.muertes).

# Devuelve un DataFrame con la cantidad de pensionados vivos que sigue viva cada año.

pob.pensionados <- function(df.pensionados, df.muertes){
  
  # Se obtienen las probabilidades de muerte para las edades de 65 en adelante y del año 2024 en adelante
  matriz.prob <- as.matrix(df.muertes[66:nrow(df.muertes), 26:ncol(df.muertes)])
  
  # Se crea un vector que contendrá la cantidad de pensionados que siguen vivos cada año
  pensionados <- c()
  
  # Los años de interés para el proyecto
  anno <- c(2024:2119)
  
  for(i in 1:96){
    
    lista.pensionados <- list()
    
    if((i - 51) > 0){
    
      for(j in (i-50):i){
        
        if(j <= 45){
          
          probabilidad <- prod(sapply(0:(i-j-1), function(k) (1 - matriz.prob[1+k, j+k])))
        
          lista.pensionados <- append(lista.pensionados, df.pensionados$pensionados[j] * probabilidad)
        
        } # fin if
          
      } # fin for j
      
    } else{
      
      for(j in 1:i){
        
        if(j <= 45){
          
          if(j == i){
            
            probabilidad <- 1
            
          } else{
        
            probabilidad <- prod(sapply(0:(i-j-1), function(k) (1 - matriz.prob[1+k, j+k])))
            
          } # fin if-else
          
          lista.pensionados <- append(lista.pensionados, df.pensionados$pensionados[j] * probabilidad)
        
        } # fin if
        
      } # fin for j
      
    } # fin if-else
    
    pensionados <- c(pensionados, sum(unlist(lista.pensionados)))
    
  } # fin for i
  
  # Se crea el dataframe con los años y los pensionados vivos y se devuelve
  df.final <- data.frame(anno = anno, pensionados = pensionados)
  
  return(df.final)
  
}

```

Se guardan las proyecciones demográficas de pensionados vivos, tanto para hombres como para mujeres.

```{r pensionados_vivos}

# Hombres pensionados vivos
pensionados.vivosh <- pob.pensionados(df.pensionadosh, qx.hombres)

# Mujeres pensionadas vivas
pensionados.vivosm <- pob.pensionados(df.pensionadosm, qx.mujeres)

```

### Proyección demográfica de defunciones de pensionados

Ahora se va a crear la función de muertes de pensionados para cada año.

```{r fun_pensionados_muertos}

# Funcion que recibe el DataFrame de los pensionados por sexo (df.pensionados) y el DataFrame de probabilidades de muertes por sexo (df.muertes).

# Devuelve un DataFrame con los pensionados fallecidos por cada año.

def.pensionados <- function(df.pensionados, df.muertes){
  
  # Se obtienen las probabilidades de muerte para las edades de 65 en adelante y del año 2024 en adelante
  matriz.prob <- as.matrix(df.muertes[66:nrow(df.muertes), 26:ncol(df.muertes)])
  
  # Se crea un vector vacío que contendrá la cantidad de pensionados fallecidos cada año
  pensionados <- c()
  
  # Los años de interés para el proyecto
  anno <- c(2024:2119)
  
  for(i in 1:96){
    
    lista.pensionados <- list()
    
    if((i - 51) > 0){
    
      for(j in (i-50):(i-1)){
        
        if(j <= 45){
          
          probabilidad.sobrevivir <- prod(sapply(0:(i-j-1), function(k) (1 - matriz.prob[1+k, j+k])))
          
          probabilidad.muerte <- matriz.prob[i-j+1, i]
        
          lista.pensionados <- append(lista.pensionados, df.pensionados$pensionados[j] * probabilidad.sobrevivir * probabilidad.muerte)
        
        } # fin if
          
      } # fin for j
      
    } else{
      
      contador <- 1
      
      for(j in 1:i){
        
        if(contador <= 45){
          
          if(j == i){
        
            probabilidad.sobrevivencia <- 1
          
            probabilidad.muerte <- matriz.prob[1, j]
          
          } else{
            
            probabilidad.sobrevivencia <- prod(sapply(0:(i-j-1), function(k) (1 - matriz.prob[1+k, j+k])))
            
            probabilidad.muerte <- matriz.prob[i-j+1, i]
            
          } # fin if-else
          
          lista.pensionados <- append(lista.pensionados, df.pensionados$pensionados[contador] * probabilidad.sobrevivencia * probabilidad.muerte)
          
          contador <- contador + 1
        
        } # fin if
        
      } # fin for j
      
    } # fin if-else
    
    pensionados <- c(pensionados, sum(unlist(lista.pensionados)))
    
  } # fin for i
  
  df.final <- data.frame(anno = anno, pensionados = pensionados)
  
  return(df.final)
  
}

```

Ahora se guardan los pensionados fallecidos durante cada año.

```{r pensionados_muertos}

# Hombres pensionados fallecidos
pensionados.fallecidosh <- def.pensionados(df.pensionadosh, qx.hombres)

# Mujeres pensionadas fallecidas
pensionados.fallecidosm <- def.pensionados(df.pensionadosm, qx.mujeres)

```

### Proyección financiera de los pagos de beneficios de muerte de empleados activos

Como primer paso, se extraen los dataframes necesarios.

```{r datos_activos}
df.activos.fallecidosm <- as.data.frame(activos.fallecidosm[[1]])
df.activos.fallecidosh <- as.data.frame(activos.fallecidosh[[1]])

# Se elimina el 2023, ya que tiene 0 muertes
df.activos.fallecidosh <- df.activos.fallecidosh[-1, ]
df.activos.fallecidosm <- df.activos.fallecidosm[-1, ]

```

Luego, se crea la función necesaria, la cual recibe un DataFrame para el calculo, y devuelve otro con los resutados. Los años son los mismos, y para el cálculo se extrae la cantidad de muertes por año de empleados activos.

```{r beneficio_activos}

ben.muerte.activos <- function(df){
  df.ben.muerte.activos = data.frame(
    año <- df[, 1],
    beneficios <- NA
  )
  vec_beneficios = c()
  for (i in 1:47) {
    beneficio <- (5000000)*((1 + 0.03)^i) * (df[i, 2]) 
    vec_beneficios <- c(vec_beneficios, beneficio) #se almacenan los beneficios en un vector
  }
  df.ben.muerte.activos$beneficios <- vec_beneficios #se guardan en el df
  return(df.ben.muerte.activos)
}

```

Se guardan y se limpian los resultados tanto para hombres como para mujeres

```{r  beneficios_muerte_activos}
ben.muerte.act.h <- ben.muerte.activos(df.activos.fallecidosh)
ben.muerte.act.m <- ben.muerte.activos(df.activos.fallecidosm)

ben.muerte.act.h <- ben.muerte.act.h[, -2]
ben.muerte.act.m <- ben.muerte.act.m[, -2]

names(ben.muerte.act.h)[names(ben.muerte.act.h) == "año....df...1."] <- "año"
names(ben.muerte.act.m)[names(ben.muerte.act.m) == "año....df...1."] <- "año"
```

### Proyección financiera de los pagos de anualidades

La siguiente función recibe un df (pensionados/as vivos/as) como parámetro y devuelve uno con las anualidades calculadas. Los años son los mismos. La anualidad se calcula como los 300 000 por la inflación por los pensionados de ese año por 13 (los pagos en los 12 meses más el aguinaldo).

```{r pago_aunalidades}
anualidades <- function(df){
  df.anualidades <- data.frame(
    año <- df[, 1],
    anualidades <- NA
  )
  vec.anualidades <- c()
  for (i in 1:length(pensionados.vivosh[,1])){
    anualidad <- 13*(300000*(1+0.03)^i)*(df[i, 2])
    vec.anualidades <- c(vec.anualidades, anualidad) #se guardan las anualidades en un vector
  }
  df.anualidades$anualidades <- vec.anualidades #se almacenan en el df
  return(df.anualidades)
}
```

Se guardan y se limpian los resultados tanto para hombres como para mujeres

```{r resultados_anualidades}
anualidades.h <- anualidades(pensionados.vivosh)
anualidades.m <- anualidades(pensionados.vivosm)

anualidades.h <- anualidades.h[, -2]
anualidades.m <- anualidades.m[, -2]

names(anualidades.h)[names(anualidades.h) == "año....df...1."] <- "año"
names(anualidades.m)[names(anualidades.m) == "año....df...1."] <- "año"

```

### Proyección financiera de los pagos de beneficios de muerte de pensionados

Se procede a realizar la funcion que calcula la proyección de los beneficios de los pensionados fallecidos

```{r benef.pensionados.muertos}

# Función que recibe un DataFrame con los pensionados fallecidos por año

# Devuelve un DataFrame con el monto que se debe tener para poder cubrir esta cantidad de muertes cada año
def.proyeccion.finac.pen <- function(df.pensionados.fallecidos) {
  
  M <- 1e6
  j <- 0.03
  
  # Se inicializa una lista del tamaño del número de filas del df para así ir guardando los montos de todos los años
  costos <- numeric(nrow(df.pensionados.fallecidos))
  
  # El for recorre cada año y cada cantidad de muertos por año, considerando la inflación
  for (i in 1:nrow(df.pensionados.fallecidos)) {
    inflacion <- (1 + j)^(i - 1)
    
    # Calcula el monto ajustado por inflación
    costos[i] <- df.pensionados.fallecidos$pensionados[i] * M * inflacion
  }
  
  # Crear un DataFrame con los resultados
  df_costos <- data.frame(
    anno = df.pensionados.fallecidos$anno,
    costo = costos
  )
  
  return(df_costos)
}

```

Se aplica la funcion para los df ya establecidos tanto de hombres como mujeres

```{r costo_pensionados}
# Aplicar la función a los pensionados fallecidos hombres y mujeres
costos.pensionados.fallecidosh <- def.proyeccion.finac.pen(pensionados.fallecidosh)
costos.pensionados.fallecidosm <- def.proyeccion.finac.pen(pensionados.fallecidosm)

```

### Cálculo de prima anual

Se crea la función que calcula primas anuales.

```{r fun_primas}
calcular.primas <- function(edad, tabla_mort) {
  tasa_j_eq <- (((1.03) * (1.04)) - 1)
  v <- (1 + 0.03) / (1 + tasa_j_eq)
  
  # Caso si muere antes de 65
  ben_muerte_act <-
    ifelse(edad >= 65,
           0,
           5000000 * Axn(edad, 2024, (64 - edad), tabla_mort, 115, tasa_j_eq))
  
  # Caso de muerte después de 65
  ben_muerte_pens <-
    1000000 * Ax(65, (2024 + 65 - edad), tabla_mort, 115, tasa_j_eq) * ((1 / (1 + tasa_j_eq)) ^ (65 - edad)) * calcular.kpx(edad, (65 - edad), tabla_mort)
  
  # Anualidad de la pensión
  ben_anualidades <-
    13 * 300000 * (((1 - Ax(
      65, (2024 + 65 - edad), tabla_mort, 115, tasa_j_eq
    )) / (1 - (1 / (
      1 + tasa_j_eq
    )))) - 1) * ((1 / (1 + tasa_j_eq)) ^ (65 - edad)) * calcular.kpx(edad, (65 - edad), tabla_mort)
  
  # Anualidad de las primas
  denominador <- ((1 - dotal(
    65, (2024 + 65 - edad), (66 - edad), tabla_mort, 115, tasa_j_eq
  )) / (1 - (1 / (1 + tasa_j_eq))))
  
  prima <-
    ((ben_muerte_act + ben_muerte_pens + ben_anualidades) / (denominador))
  
  return(list(
    prima = prima,
    vp = (ben_muerte_act + ben_muerte_pens + ben_anualidades),
    anualidad = denominador
  ))
}

```

Para almacenar los datos de las primas, se usa como base el DataFrame empleados.

```{r datos_para_primas}
datos.hombres <- empleados[empleados$sexo == "M", ]

datos.hombres <- datos.hombres[, -c(1, 2, 4, 5)] 
datos.hombres <- datos.hombres[!duplicated(datos.hombres$edad), ]

datos.mujeres <- empleados[empleados$sexo == "F", ]

datos.mujeres <- datos.mujeres[, -c(1, 2, 4, 5)] 
datos.mujeres <- datos.mujeres[!duplicated(datos.mujeres$edad), ]
```

Se calculan las primas para hombres y mujeres, y se guardan en el DataFrame de datos de cada uno.

```{r resultados_primas}
resultados.hombres <- lapply(21:65, function(p) calcular.primas(p, qx.hombres))
primas.hombres <- sapply(resultados.hombres, function(res) res$prima)
vp.hombres <- sapply(resultados.hombres, function(res) res$vp)
anualidad.hombres <- sapply(resultados.hombres, function(res) res$anualidad)

resultados.mujeres <- lapply(21:65, function(l) calcular.primas(l, qx.mujeres))
primas.mujeres <- sapply(resultados.mujeres, function(res) res$prima)
vp.mujeres <- sapply(resultados.mujeres, function(res) res$vp)
anualidad.mujeres <- sapply(resultados.mujeres, function(res) res$anualidad)
```

Se agregan las columnas correspondientes.

```{r primas_vp_anualidades}
datos.hombres[["primas"]] <- primas.hombres
datos.hombres[["vp"]] <- vp.hombres
datos.hombres[["anualidad"]] <- anualidad.hombres

datos.mujeres[["primas"]] <- primas.mujeres
datos.mujeres[["vp"]] <- vp.mujeres
datos.mujeres[["anualidad"]] <- anualidad.mujeres
```

La prima nivelada.

```{r prima_nivelada}
prima_nivelada <- (sum(datos.hombres$vp) + sum(datos.mujeres$vp)) / (sum(datos.hombres$anualidad) + sum(datos.mujeres$anualidad))

print(paste("La prima media nivelada es:", round(prima_nivelada, 2)))
```

```{r eliminar_columnas_innecesarias}
datos.hombres <- datos.hombres %>%
  select(-vp, -anualidad)

datos.mujeres <- datos.mujeres %>%
  select(-vp, -anualidad)
```

### Métodos de reducciones de primas en un 10%

En el primer método se va a reducir el monto de la pensión por aproximación manual. Al reducir los pagos mensuales, los costos mensuales se disminuyen, lo cual resulta beneficioso para la empresa, ya que necesitaria menos fondos para cubrir sus gastos. Sin embargo, trae efectos negativos en los empleados, principalmente debido a que el monto de la pension se va a reducir.

```{r reduccion_primas_1}
calcular.primas.metodo1 <- function(edad, tabla_mort) {
  tasa_j_eq <- (((1.03) * (1.04)) - 1)
  v <- (1 + 0.03) / (1 + tasa_j_eq)
  
  # Caso si muere antes de 65
  ben_muerte_act <-
    ifelse(edad >= 65,
           0,
           5000000 * Axn(edad, 2024, (64 - edad), tabla_mort, 115, tasa_j_eq))
  
  # Caso de muerte después de 65
  ben_muerte_pens <-
    1000000 * Ax(65, (2024 + 65 - edad), tabla_mort, 115, tasa_j_eq) * ((1 / (1 + tasa_j_eq)) ^ (65 - edad)) * calcular.kpx(edad, (65 - edad), tabla_mort)
  
  # Pensión
  ben_anualidades <-
    13 * 265500 * (((1 - Ax(
      65, (2024 + 65 - edad), tabla_mort, 115, tasa_j_eq
    )) / (1 - (1 / (1 + tasa_j_eq)))) - 1) * ((1 / (1 + tasa_j_eq)) ^ (65 - edad)) * calcular.kpx(edad, (65 - edad), tabla_mort)
  
  # Anualidad de las primas
  denominador <- ((1 - dotal(
      65, (2024 + 65 - edad), (66 - edad), tabla_mort, 115, tasa_j_eq
    )) / (1 - (1 / (1 + tasa_j_eq))))
  
  prima <- ((ben_muerte_act + ben_muerte_pens + ben_anualidades) / (denominador))
  
  return(prima)
}

```

```{r reduccion_primas_metodo1}
primas.hombres.metodo1 <- sapply((21:65), function(p) calcular.primas.metodo1(p, qx.hombres))
primas.mujeres.metodo1 <- sapply((21:65), function(l) calcular.primas.metodo1(l, qx.mujeres))

datos.hombres$primas.metodo1 <- primas.hombres.metodo1
datos.mujeres$primas.metodo1 <- primas.mujeres.metodo1

datos.hombres$porcentaje.metodo1 <- datos.hombres$primas.metodo1 / datos.hombres$primas
datos.mujeres$porcentaje.metodo1 <- datos.mujeres$primas.metodo1 / datos.mujeres$primas
```

Seguidamente se calculará el promedio de las primas del método 1 y el promedio de las primas originales, para ambos sexos, para luego dividir, respectivamente, estos dos resultados, con el fin de notar que se logra reducir en promedio las primas en un $10\%$.

```{r promedio_metodo1}
mean(datos.hombres$primas.metodo1[1:45]) / mean(datos.hombres$primas[1:45])
mean(datos.mujeres$primas.metodo1[1:45]) / mean(datos.mujeres$primas[1:45])
```

Para el segundo método de reducción en un 10% de las primas, se tomaron varios supuestos. Primero, ahora las personas se pueden pensionar hasta la edad de 67 años y no a los 65; además, el monto de la pensión se redujo en 2 mil colones, lo que puede parecer un monto bajo, pero al ser un monto que se paga anualmente hasta que la persona muera se puede convertir en suma bastante considerable. También se redujo el beneficio de muerte de empleado activo a dos millones novecientos mil, y de igual forma el monto de beneficio en caso de muerte del pensionado se disminuyó a setecientos sesenta mil.

```{r reduccion_primas_2}
calcular.primas.metodo2 <- function(edad, tabla_mort) {
  tasa_j_eq <- (((1.03) * (1.04)) - 1)
  v <- (1 + 0.03) / (1 + tasa_j_eq)
  
  # Caso si muere antes de 67
  ben_muerte_act <-
    ifelse(edad >= 67,
           0,
           2900000 * Axn(edad, 2024, (66 - edad), tabla_mort, 115, tasa_j_eq))
  
  # Caso de muerte después de 67
  ben_muerte_pens <-
    760000 * Ax(67, (2024 + 67 - edad), tabla_mort, 115, tasa_j_eq) * ((1 / (1 + tasa_j_eq)) ^ (67 - edad)) * calcular.kpx(edad, (67 - edad), tabla_mort)
  
  # Pensión
  ben_anualidades <-
    13 * 298000 * (((1 - Ax(
      67, (2024 + 67 - edad), tabla_mort, 115, tasa_j_eq
    )) / (1 - (1 / (1 + tasa_j_eq)))) - 1) * ((1 / (1 + tasa_j_eq)) ^ (67 - edad)) * calcular.kpx(edad, (67 - edad), tabla_mort)
  
  # Anualidad de las primas
  denominador <- ((1 - dotal(
      67, (2024 + 67 - edad), (68 - edad), tabla_mort, 115, tasa_j_eq
    )) / (1 - (1 / (1 + tasa_j_eq))))
  
  prima <- ((ben_muerte_act + ben_muerte_pens + ben_anualidades) / (denominador))
  
  return(prima)
}
```

```{r reduccion_primas_metodo2}
fila.nula1 <- data.frame(edad = NA, primas = NA, primas.metodo1 = NA, porcentaje.metodo1 = NA)
fila.nula2 <- data.frame(edad = NA, primas = NA, primas.metodo1 = NA, porcentaje.metodo1 = NA)

datos.hombres <- rbind(datos.hombres, fila.nula1, fila.nula2)
datos.mujeres <- rbind(datos.mujeres, fila.nula1, fila.nula2)

rm(fila.nula1)
rm(fila.nula2)

# Hacemos un sapply para poder obtener la prima de cada edad, tanto de hombres como de mujeres
primas.hombres.metodo2 <- sapply((21:67), function(p) calcular.primas.metodo2(p, qx.hombres))
primas.mujeres.metodo2 <- sapply((21:67), function(l) calcular.primas.metodo2(l, qx.mujeres))

datos.hombres$primas.metodo2 <- primas.hombres.metodo2
datos.mujeres$primas.metodo2 <- primas.mujeres.metodo2

datos.hombres$porcentaje.metodo2 <- datos.hombres$primas.metodo2 / datos.hombres$primas
datos.mujeres$porcentaje.metodo2 <- datos.mujeres$primas.metodo2 / datos.mujeres$primas
```

Ahora vamos a ver que, si sacamos el promedio a estas 67 primas y el promedio de las primeras 65 primas originales, para ambos sexos, tomando el primer resultado y dividiéndolo entre el original de las 65 primas, se puede notar que se logra reducir en promedio las primas en un $10\%$.

```{r promedio_metodo2}
mean(datos.hombres$primas.metodo2) / mean(datos.hombres$primas[1:45])
mean(datos.mujeres$primas.metodo2) / mean(datos.mujeres$primas[1:45])
```

## Modelo estocástico

Inicialmente, se extraen las probabilidades de supervivencia que se usarán para el modelo.

```{r prob_sobrevivencia}
# Probabilidades de sobrevivencia
densidad.h <- 1 - sapply(22:116, function(x) qx.hombres[[x, 4 + x]])
densidad.m <- 1 - sapply(22:116, function(x) qx.mujeres[[x, 4 + x]])
```

Posteriormente, se realiza manualmente la primera iteración del modelo, pues la función recibirá como parámetro la primera prima calculada.

```{r primera_iteracion}
# Lista para resultados
lista.primash <- list()
lista.primasm <- list()

# Tasa equivalente
j <- ((1.04) * (1.03)) - 1

# Todas las probabilidades de muerte, de hombres, de 21 hasta 65
prob.muerteh <- sapply(1:45, function(i) sapply(((21 + i)):116, function(k) qx.hombres[[k, 25 + k]]))

# Matriz de probabilidades de supervivencia, de hombres, desde edad inicial 21 hasta edad inicial 65, cada fila es una persona de edad 21, 22, 23, ...
matriz.probh <- (1 - t(as.matrix(sapply((1:length(prob.muerteh)), function(l) c(prob.muerteh[[l]], rep(1, (length(prob.muerteh[[1]]) - length(prob.muerteh[[l]]) + 1)))))))

# Todas las probabilidades de muerte, de mujeres, de 21 hasta 65
prob.muertem <- sapply(1:45, function(i) sapply(((21 + i)):116, function(k) qx.mujeres[[k, 25 + k]]))

# Matriz de probabilidades de supervivencia, de mujeres, desde edad inicial 21 hasta edad inicial 65, cada fila es una persona de edad 21, 22, 23, ...
matriz.probm <- (1 - t(as.matrix(sapply((1:length(prob.muertem)), function(l) c(prob.muertem[[l]], rep(1, (length(prob.muertem[[1]]) - length(prob.muertem[[l]]) + 1)))))))

# Se eliminan las columnas innecesarias
matriz.probh <- matriz.probh[, 1:(ncol(matriz.probh) - 1)]
matriz.probm <- matriz.probm[, 1:(ncol(matriz.probm) - 1)]

# Nombres de filas y columnas
colnames(matriz.probh) <- c(2024: (2024 + 115 - 21))
colnames(matriz.probm) <- c(2024: (2024 + 115 - 21))
rownames(matriz.probh) <- c(21:65)
rownames(matriz.probm) <- c(21:65)

# El número de filas y columnas es fijo, entonces se guardará para que no se calcule en cada iteración después
colmat <- ncol(matriz.probh)
filmat <- nrow(matriz.probm)

# Creamos las matrices de números aleatorios
matriz.rndh <- matrix(data = pnorm(rnorm(colmat * filmat, 0, sd = 1), mean = 0, sd = 1), nrow = filmat, ncol = colmat)

matriz.rndm <- matrix(data = pnorm(rnorm(colmat * filmat, 0, sd = 1), mean = 0, sd = 1), nrow = filmat, ncol = colmat)

# Comparación de matrices
matriz.rndh <- matriz.rndh < matriz.probh
matriz.rndm <- matriz.rndm < matriz.probm

# Se agregan los falsos después del primer falso de la matriz
matriz.rndh <- t(apply(matriz.rndh, 1, fila.muerte))
matriz.rndm <- t(apply(matriz.rndm, 1, fila.muerte))

# Índice del primer falso
idh <- sapply(1:filmat, function(m) which(!matriz.rndh[m, ])[1]) - 1
idm <- sapply(1:filmat, function(m) which(!matriz.rndm[m, ])[1]) - 1

# Anualidades
anh <- sapply(1:filmat, function(n) sum((1 + j) ^ -(0:(min(idh[n], (65 - 20 - n))))))
anm <- sapply(1:filmat, function(n) sum((1 + j) ^ -(0:(min(idh[n], (65 - 20 - n))))))

# Rango de años de cada persona desde que llega a 65 años hasta que fallece
annosh.65 <- sapply(21:65, function(o) c((65 - o + 1):(idh[[o - 20]] + 1)))
annosm.65 <- sapply(21:65, function(o) c((65 - o + 1):(idm[[o - 20]] + 1)))

# Beneficios para trabajadores y pensionados
benh <- sapply(1:length(annosh.65), function(p) (ifelse(idh + c(21:65) < 65, 5000000 * ((1 + j) ^ -(idh + 1)), sum(300000 * 13 * (1 + j) ^ -annosh.65[[p]]) + 1000000 * ((1 + j) ^ -(idh + 1))))[p])

benm <- sapply(1:length(annosm.65), function(p) (ifelse(idm + c(21:65) < 65, 5000000 * ((1 + j) ^ -(idm + 1)), sum(300000 * 13 * (1 + j) ^ -annosm.65[[p]]) + 1000000 * ((1 + j) ^ -(idm + 1))))[p])

# Guardamos el resultado
lista.primash[[1]] <- (benh / anh)
lista.primasm[[1]] <- (benm / anm)
```

Posteriormente, se realiza la función que se encarga de las demás iteraciones del modelo estocástico.

```{r siguientes_iteraciones}
modelo.estocastico <- function(matriz.prob, prom.primas, densidad, lista.primas){
  while (abs(prom.primas - mean(unlist(lista.primas))) > 0.001) {
    
  # Creamos la matriz de números aleatorios
  matriz.rnd <- matrix(data = pnorm(rnorm(colmat * filmat, mean = 0, sd = 1), mean = 0, sd = 1), nrow = filmat, ncol = colmat)
  
  # Comparación de matrices
  matriz.rnd <- matriz.rnd < matriz.prob
  
  # Se agregan los falsos después del primer falso de la matriz
  matriz.rnd <- t(apply(matriz.rnd, 1, fila.muerte))
  
  # Índice del primer falso
  id <- sapply(1:filmat, function(m) which(!matriz.rnd[m, ])[1]) - 1
  
  # Anualidad
  an <- sapply(1:filmat, function(n) sum((1 + j) ^ -(0:id[n])))
  
  # Rango de años de cada persona desde que llega a 65 años hasta que fallece
  annos.65 <- sapply(21:65, function(o) c((65 - o + 1):(id[[o - 20]] + 1)))
  
  # Beneficios para trabajadores y pensionados
  ben <- sapply(1:length(annos.65), function(p) (ifelse(id + c(21:65) < 65, 5000000 * ((1 + j) ^ -(id + 1)), sum(300000 * 13 * (1 + j) ^ -annos.65[[p]]) + 1000000 * ((1 + j) ^ -(id + 1))))[p])
  
  # Actualizamos el promedio correspondiente
  prom.primas <- mean(unlist(lista.primas))
  
  # Primas
  lista.primas <- append(lista.primas, list(ben / an))
  
  }
  
  # Se devuelven las primas de cada iteración
  return(lista.primas)
  }
```

Probamos el modelo para cada género.

```{r modelo_estocastico}
primas.estocasticash <- modelo.estocastico(matriz.probh, 0, densidad.h, lista.primash)
primas.estocasticasm <- modelo.estocastico(matriz.probm, 0, densidad.m, lista.primasm)
```

Para comparar con las primas del modelo determinístico, se procede a extraer el cuartíl 50 y 90 de cada edad para todas las simulaciones.

```{r cuartiles_estocasticos}
# Inicialmente, se pasan a matrices las simulaciones
matriz.estoch <- do.call(cbind, primas.estocasticash)
matriz.estocm <- do.call(cbind, primas.estocasticasm)

# Se agrega formato a las filas de estas
rownames(matriz.estoch) <- c(21:65)
rownames(matriz.estocm) <- c(21:65)

# Se extraen los cuartiles correspondientes y se dejan en un DataFrame
df.primash <- data.frame(primas_originales = datos.hombres$primas[1:45],
                         primas_cuartil_50 = apply(matriz.estoch, MARGIN = 1, FUN = median),
                         primas_cuartil_90 = apply(matriz.estoch, MARGIN = 1, FUN = quantile, probs = 0.9))

df.primasm <- data.frame(primas_originales = datos.mujeres$primas[1:45],
                         primas_cuartil_50 = apply(matriz.estocm, MARGIN = 1, FUN = median),
                         primas_cuartil_90 = apply(matriz.estocm, MARGIN = 1, FUN = quantile, probs = 0.9))
```

## Gráficos

En esta sección se pondrán todos los gráficos que se presenten para el proyecto. Iniciando con algunos gráficos que describen la base de datos a trabajar.

```{r bd_empleados}
# Gráfico de edades de los empleados
ggplot(empleados, aes(x = edad)) +
  geom_histogram(binwidth = 1, fill = "seagreen3", color = "black") +
  labs(x = "Edad", y = "Cantidad", caption = "Fuente: elaboración propia") +
  theme_minimal()

# Gráfico de sexos de la empresa
ggplot(empleados, aes(x = sexo, fill = sexo)) +
  geom_bar() +
  labs(x = "Sexo", y = "Cantidad", caption = "Fuente: elaboración propia") +
  theme_minimal() +
  scale_fill_manual(name = "Sexo",
                    values = c("cornflowerblue", "lightcoral"))
```

Después, las proyecciones demográficas de empleados activos.

```{r comparacion_empleados_activos}
# Se inicia juntando los datos necesarios en un DataFrame
df.grafico <- data.frame(
  años = activos.fallecidosh[[1]]$anno,
  vivosh = activos.vivosh[[1]]$trabajadores,
  vivosm = activos.vivosm[[1]]$trabajadores,
  defunch = cumsum(activos.fallecidosh[[1]]$trabajadores),
  defuncm = cumsum(activos.fallecidosm[[1]]$trabajadores)
)

df.grafico$sumah <- df.grafico$vivosh + df.grafico$defunch
df.grafico$sumam <- df.grafico$vivosm + df.grafico$defuncm

# Gráfico para hombres
ggplot(df.grafico, aes(x = años)) +
  geom_line(aes(y = vivosh, color = "Vivos por año")) +
  geom_line(aes(y = defunch, color = "Fallecidos acumulados")) +
  geom_line(aes(y = sumah, color = "Totales por año")) +
  labs(
    x = "Años",
    y = "Cantidad de personas",
    caption = "Fuente: elaboración propia"
  ) +
  scale_colour_manual(
    name = "Empleados",
    values = c(
      "Vivos por año" = "darkorchid",
      "Fallecidos acumulados" = "deeppink3",
      "Totales por año" = "indianred2"
    )
  ) +
  theme_minimal()

# Gráfico para mujeres
ggplot(df.grafico, aes(x = años)) +
  geom_line(aes(y = vivosm, color = "Vivas por año")) +
  geom_line(aes(y = defuncm, color = "Fallecidas acumuladas")) +
  geom_line(aes(y = sumam, color = "Totales por año")) +
  labs(
    x = "Años",
    y = "Cantidad de personas",
    caption = "Fuente: elaboración propia"
  ) +
  scale_colour_manual(
    name = "Empleados",
    values = c(
      "Vivas por año" = "cyan3",
      "Fallecidas acumuladas" = "deepskyblue2",
      "Totales por año" = "lightblue3"
    )
  ) +
  theme_minimal()

# La variable no re ocupará más adelante, por lo que se elimina
rm(df.grafico)
```

Luego, las proyecciones demográficas para pensionados.

```{r comparacion_pensionados}
# Se crea un DataFrame con los datos necesarios
df.grafico <- data.frame(
  años = pensionados.fallecidosh$anno,
  vivosh = pensionados.vivosh$pensionados,
  vivosm = pensionados.vivosm$pensionados,
  defunch = cumsum(pensionados.fallecidosh$pensionados),
  defuncm = cumsum(pensionados.fallecidosm$pensionados)
)

df.grafico$sumah <- df.grafico$vivosh + df.grafico$defunch
df.grafico$sumam <- df.grafico$vivosm + df.grafico$defuncm

# Gráfico para hombres
ggplot(df.grafico, aes(x = años)) +
  geom_line(aes(y = vivosh, color = "Vivos por año")) +
  geom_line(aes(y = defunch, color = "Fallecidos acumulados")) +
  geom_line(aes(y = sumah, color = "Totales por año")) +
  labs(
    x = "Años",
    y = "Cantidad de personas",
    caption = "Fuente: elaboración propia"
  ) +
  scale_colour_manual(
    name = "Pensionados",
    values = c(
      "Vivos por año" = "skyblue",
      "Fallecidos acumulados" = "indianred",
      "Totales por año" = "purple"
    )
  ) +
  theme_minimal()

# Gráfico para mujeres
ggplot(df.grafico, aes(x = años)) +
  geom_line(aes(y = vivosm, color = "Vivas por año")) +
  geom_line(aes(y = defuncm, color = "Fallecidas acumuladas")) +
  geom_line(aes(y = sumam, color = "Totales por año")) +
  labs(
    x = "Años",
    y = "Cantidad de personas",
    caption = "Fuente: elaboración propia"
  ) +
  scale_colour_manual(
    name = "Pensionadas",
    values = c(
      "Vivas por año" = "cyan2",
      "Fallecidas acumuladas" = "pink2",
      "Totales por año" = "orange2"
    )
  ) +
  theme_minimal()

# Se elimina la variable que guarda el gráfico
rm(df.grafico)
```

Posteriormente, los gráficos de comparación de primas.

```{r comparacion_primas}

# Comparación entre los percentiles 50 y 90 de las primas del modelo estocástico (hombres)
ggplot(df.primash, aes(x = c(21:65))) +
  geom_line(aes(y = (primas_cuartil_50 / 1000000), color = "Cuartíl 50")) +
  geom_line(aes(y = (primas_cuartil_90 / 1000000), color = "Cuartíl 90")) +
  labs(
    x = "Edades",
    y = "Cantidad de Prima (millones)",
    caption = "Fuente: elaboración propia"
  ) +
  scale_colour_manual(
    name = "Primas Estocásticas",
    values = c(
      "Cuartíl 50" = "brown3",
      "Cuartíl 90" = "darkorange2"
    )
  ) +
  theme_minimal()

# Comparación entre los percentiles 50 y 90 de las primas del modelo estocástico (mujeres)
ggplot(df.primasm, aes(x = c(21:65))) +
  geom_line(aes(y = (primas_cuartil_50 / 1000000), color = "Cuartíl 50")) +
  geom_line(aes(y = (primas_cuartil_90 / 1000000), color = "Cuartíl 90")) +
  labs(
    x = "Edades",
    y = "Cantidad de Prima (millones)",
    caption = "Fuente: elaboración propia"
  ) +
  scale_colour_manual(
    name = "Primas Estocásticas",
    values = c(
      "Cuartíl 50" = "yellow3",
      "Cuartíl 90" = "darkviolet"
    )
  ) +
  theme_minimal()

################################################################################

# Comparación entre las primas originales con los percentiles 50 y 90 de las primas estocásticas (hombres)
ggplot(df.primash, aes(x = c(21:65))) +
  geom_line(aes(y = (primas_originales / 1000000), color = "Primas determinísticas")) +
  geom_line(aes(y = (primas_cuartil_50 / 1000000), color = "Cuartíl 50 de primas estocásticas")) +
  geom_line(aes(y = (primas_cuartil_90 / 1000000), color = "Cuartíl 90 de primas estocásticas")) +
  labs(
    x = "Edades",
    y = "Cantidad de Prima (millones)",
    caption = "Fuente: elaboración propia"
  ) +
  scale_colour_manual(
    name = "Primas",
    values = c(
      "Primas determinísticas" = "green4",
      "Cuartíl 50 de primas estocásticas" = "brown3",
      "Cuartíl 90 de primas estocásticas" = "darkorange2"
    )
  ) +
  theme_minimal()

# Comparación entre las primas originales con los percentiles 50 y 90 de las primas estocásticas (mujeres)
ggplot(df.primasm, aes(x = c(21:65))) +
  geom_line(aes(y = (primas_originales / 1000000), color = "Primas determinísticas")) +
  geom_line(aes(y = (primas_cuartil_50 / 1000000), color = "Cuartíl 50 de primas estocásticas")) +
  geom_line(aes(y = (primas_cuartil_90 / 1000000), color = "Cuartíl 90 de primas estocásticas")) +
  labs(
    x = "Edades",
    y = "Cantidad de Prima (millones)",
    caption = "Fuente: elaboración propia"
  ) +
  scale_colour_manual(
    name = "Primas",
    values = c(
      "Primas determinísticas" = "darkred",
      "Cuartíl 50 de primas estocásticas" = "yellow3",
      "Cuartíl 90 de primas estocásticas" = "darkviolet"
    )
  ) +
  theme_minimal()

```

Siguiendo con los gráficos de proyecciones financieras.

```{r proyeccion_finac_muertes_empleados}
ben.muerte.act.h$genero <- "Hombres"
ben.muerte.act.m$genero <- "Mujeres"

# Combinar los DataFrames
beneficios.combinados <- rbind(ben.muerte.act.h, ben.muerte.act.m)

# Crear el gráfico combinado
ggplot(beneficios.combinados, aes(x = año)) +
  geom_line(aes(y = (beneficios / 1000000), color = genero), linewidth = 1) +
  labs(x = "Año",
       y = "Costo ajustado por inflación (millones)",
       caption = "Fuente: elaboración propia") +
  scale_color_manual(
    name = "Género",
    values = c("Hombres" = "blue", "Mujeres" = "pink")) +
  theme_minimal()
```

```{r proyeccion_finac_muertes_pensionados}
costos.pensionados.fallecidosh$genero <- "Hombres"
costos.pensionados.fallecidosm$genero <- "Mujeres"

# Combinar los DataFrames
costos.combinados <- rbind(costos.pensionados.fallecidosh, costos.pensionados.fallecidosm)

# Crear el gráfico combinado
ggplot(costos.combinados, aes(x = anno)) +
  geom_line(aes(y = (costo / 1000000), color = genero), linewidth = 1) +
  labs(x = "Año",
       y = "Costo ajustado por inflación (millones)",
       caption = "Fuente: elaboración propia") +
  scale_color_manual(
    name = "Género",
    values = c("Hombres" = "blue", "Mujeres" = "pink")) +
  theme_minimal()
```

```{r proyeccion.finac.anualidades}
anualidades.h$genero <- "Hombres"
anualidades.m$genero <- "Mujeres"

# Combinar los DataFrames
anualidades.combinadas <- rbind(anualidades.h, anualidades.m)

# Crear el gráfico combinado
ggplot(anualidades.combinadas, aes(x = año)) +
  geom_line(aes(y = (anualidades/ 1000000), color = genero), linewidth = 1) +
  labs(x = "Año",
       y = "Costo ajustado por inflación (millones)",
       caption = "Fuente: elaboración propia") +
  scale_color_manual(
    name = "Género",
    values = c("Hombres" = "blue", "Mujeres" = "pink")) +
  theme_minimal()
```

Gráficos de las primas

```{r primas}

datos.hombres$genero <- "Hombres"
datos.mujeres$genero <- "Mujeres"

# Combinar los DataFrames
primas.combinadas <- rbind(datos.hombres, datos.mujeres)

primas.combinadas[is.na(primas.combinadas)] <- 0

# Crear el gráfico combinado
ggplot(primas.combinadas, aes(x = edad)) +
  geom_line(aes(y = (primas/1000000), color = genero), linewidth = 1) +
  labs(x = "Edad",
       y = "Primas por pagar (millones)",
       caption = "Fuente: elaboración propia") +
  scale_color_manual(
    name = "Género",
    values = c("Hombres" = "blue", "Mujeres" = "pink")) +
  theme_minimal()

```

Luego, las comparaciones de primas para hombres.

```{r tipos_primas}
# Extraemos las columnas que ocupamos de cada df
primas.metodo1 <- datos.hombres[1:45, c("edad", "porcentaje.metodo1")]
primas.metodo2 <- datos.hombres[1:45, c("edad", "porcentaje.metodo2")]

# Fusionamos los df en uno solo por la edad
primas.combinadas <- merge(primas.metodo1, primas.metodo2, by = "edad", all = TRUE)

# Crear el gráfico combinado
ggplot(primas.combinadas, aes(x = edad)) +
  geom_line(aes(y = porcentaje.metodo1, color = "Método 1")) +
  geom_line(aes(y = porcentaje.metodo2, color = "Método 2")) +
  labs(x = "Edad",
       y = "Porcentaje de Primas",
       caption = "Fuente: elaboración propia") +
  scale_color_manual(
    name = "Tipo de Primas",
    values = c(
      "Método 1" = "blue", 
      "Método 2" = "red")) +
  theme_minimal()

# Analogamente se hace un gráfico para las mujeres
primas.metodo1 <- datos.mujeres[1:45, c("edad", "porcentaje.metodo1")]
primas.metodo2 <- datos.mujeres[1:45, c("edad", "porcentaje.metodo2")]

primas.combinadas <- merge(primas.metodo1, primas.metodo2, by = "edad", all = TRUE)

ggplot(primas.combinadas, aes(x = edad)) +
  geom_line(aes(y = porcentaje.metodo1, color = "Método 1")) +
  geom_line(aes(y = porcentaje.metodo2, color = "Método 2")) +
  labs(x = "Edad",
       y = "Porcentaje de Primas",
       caption = "Fuente: elaboración propia") +
  scale_color_manual(
    name = "Tipo de Primas",
    values = c(
      "Método 1" = "skyblue2", 
      "Método 2" = "indianred2")) +
  theme_minimal()

# Se eliminan las variables innecesarias
rm(primas.metodo1, primas.metodo2, primas.combinadas)
```
