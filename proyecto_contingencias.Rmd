---
title: "proyecto_contingencias"
author: "Alejandro Brenes - C21319, Santiago Fernández - C22943, Félix Madrigal -
  C24459 y Eyeri Méndez - C24765"
date: "`r Sys.Date()`"
output: html_document
---

# Proyecto contingencias I

## Librerías necesarias

```{r librerías}

pacman::p_load(readxl,
               ggplot2,
               dplyr,
               data.table)

```


## Descarga de datos

Se inicia con la descarga de los datos, para la base de datos de los empleados se agregaron columnas con la edad y el año de nacimiento, para los valores tqx se realizó una tabla dinámica separada por cada sexo, todos los cambios fueron hechos desde MS Excel.

```{r descarga_datos}

empleados <- read_excel("datos/Base de datos.xlsx")
qx.hombres <- read_excel("datos/tavid2000-2150.xlsx", 
    sheet = "Sexo_1_limpio")
qx.mujeres <- read_excel("datos/tavid2000-2150.xlsx", 
    sheet = "Sexo_2_limpio")

```

Se cambia el nombre y el orden las columnas de la base de empleados.

```{r corr_columnas}

# Nombre de columnas
empleados <- empleados %>% 
  rename(
    id = "Número de empleado",
    fecha_nac = "Fecha de nacimiento",
    sexo = Sexo,
    edad = Edad,
    anno_nac = Anno_nac
  )

# Se reordena el DataFrame
empleados <- empleados %>%
  dplyr::select(id, sexo, edad, anno_nac, fecha_nac)
```

La edad de las personas se calculó para 2023, se requiere la de 2024, por los que se suma una unidad a esa columna.

```{r corr_edad}
empleados$edad <- empleados$edad + 1
```

## Modelo determinístico

### Proyección demográfica de población de empleados activos

Se creará una función para determinar los empleados activos que continúan vivos cada año por sexo.

```{r fun_activos_vivos}
# La siguiente funcion recibe el DataFrame de los empleados (df.empleados), el DataFrame de probabilidades de muertes por sexo (df.muertes) y el sexo a calcular su proyección (sexo). Es importante que el sexo coincida con el sexo de las probabilidades de muerte, de lo contrario, podría conducir a errores en el cálculo. Se devuelve una lista con: un DataFrame con la población activa que sigue viva por cada año y la matriz de sobrevivientes por edad
pob.activos <- function(df.empleados, df.muertes, sexo) {
  # Se filtra el DataFrame por el sexo
  if (sexo == "M") {
    df.empleados <- df.empleados %>%
      filter(sexo == "M")
  }
  else if (sexo == "F") {
    df.empleados <- df.empleados %>%
      filter(sexo == "F")
  }
  else{
    return("El sexo del parámetro no fue encontrado")
  }
  
  # Las edades de las personas que nos interesan para el estudio
  edades <- c(min(df.empleados$edad):65)
  
  # Contamos la cantidad de personas que hay por cada edad
  num.personas <- as.vector(table(as.factor(df.empleados$edad)))
  
  # Lista para guardar las probabilidades de sobrevivencia
  lista.tpx <- list()
  
  # Se itera para obtener las probabilidades de sobrevivencia de cada edad
  for (edad in edades) {
    # Se obtiene un vector de qx de forma diagonal
    tqx <-
      sapply(0:(65 - edad), function(j)
        as.numeric(df.muertes[edad + 1 + j,  26 + j]))
    
    # Calcula los tpx a partir de los tqx de forma acumulativa
    tpx <-
      c(1, sapply(1:(length(tqx)), function(k)
        prod(1 - tqx[1:k])))
    
    # La longitud de los tpx va disminuyendo, por lo que calculamos los 0 necesarios para formar una matriz posteriormente
    if ((48 - length(tpx)) > 0) {
      tpx <- c(tpx, rep(0, (48 - length(tpx))))
    }
    
    lista.tpx[[(edad - 20)]] <- tpx
  }
  
  # Con todos los vectores en una lista, creamos la matriz, en donde cada fila es la probabilidad de sobrevivencia de una persona de edad x
  matriz.prob <- do.call(rbind, lista.tpx)
  
  # Se realiza la multiplicación de personas por su probabilidad de sobrevivencia
  matriz.final <- num.personas * matriz.prob
  
  # Se crea un dataframe con la cantidad de personas restantes por año, para esto se sumarán las columnas de la matriz anterior
  df.resultado <-
    data.frame(anno = c(2023:(2091 - min(edades))),
               # 2024 + 65 + 1 - min(edades)
               trabajadores = colSums(matriz.final))
  
  # Se devolverá una lista, primero tendrá el resultado en DataFrame y posteriormente tendrá la matriz que indica cuántas personas se pensionarion cada año
  lista.res <- list(df.resultado, matriz.final)
  
  return(lista.res)
}
```

Se guardan las proyecciones demográficas para hombres y mujeres.

```{r act_vivos}
# Hombres activos vivos
activos.vivosh <- pob.activos(empleados, qx.hombres, "M")

# Mujeres activas vivas
activos.vivosm <- pob.activos(empleados, qx.mujeres, "F")
```

### Proyección demográfica de defunciones de empleados activos

Se procede a crear la función de muertes de empleados activos cada año.

```{r fun_activos_muertos}
# La siguiente funcion recibe el DataFrame de los empleados (df.empleados), el DataFrame de probabilidades de muertes por sexo (df.muertes) y el sexo a calcular su proyección (sexo). Es importante que el sexo coincida con el sexo de las probabilidades de muerte, de lo contrario, podría conducir a errores en el cálculo. Se devuelve una lista con: un DataFrame con los fallecidos por cada año y la matriz de fallecidos por edad
def.activos <- function(df.empleados, df.muertes, sexo) {
  # Se filtra el DataFrame por el sexo
  if (sexo == "M") {
    df.empleados <- df.empleados %>%
      filter(sexo == "M")
  }
  else if (sexo == "F") {
    df.empleados <- df.empleados %>%
      filter(sexo == "F")
  }
  else{
    return("El sexo del parámetro no fue encontrado")
  }
  
  # Las edades de las personas que nos interesan para el estudio
  edades <- c(min(df.empleados$edad):65)
  
  # Contamos la cantidad de personas que hay por cada edad
  num.personas <- as.vector(table(as.factor(df.empleados$edad)))
  
  # Lista para guardar las probabilidades de sobrevivencia
  lista.tqx <- list()
  
  # Se itera para obtener las probabilidades de sobrevivencia de cada edad
  for (edad in edades) {
    # Se obtiene un vector de qx de forma diagonal
    qx <-
      sapply(0:(65 - edad), function(j)
        as.numeric(df.muertes[edad + 1 + j,  26 + j]))
    
    # Calcula los tpx a partir de los tqx de forma acumulativa
    tpx <-
      sapply(1:(length(qx)), function(k)
        prod(1 - qx[1:k]))
    
    # Calcula los t|qx a partir de los qx y los tpx de forma acumulativa
    
    if (length(qx) == 1) {
      c(0, qx[1])
    }
    else{
      tqx <-
        c(0, qx[1], sapply(2:(length(qx)), function(l)
          (tpx[(l - 1)] * qx[l])))
    }
    
    # La longitud de los tqx va disminuyendo, por lo que calculamos los 0 necesarios para formar una matriz posteriormente
    if ((48 - length(tqx)) > 0) {
      tqx <- c(tqx, rep(0, (48 - length(tqx))))
    }
    
    lista.tqx[[(edad - 20)]] <- tqx
  }
  
  # Con todos los vectores en una lista, creamos la matriz, en donde cada fila es la probabilidad de sobrevivencia de una persona de edad x
  matriz.prob <-
    matrix(unlist(lista.tqx),
           nrow = length(lista.tqx),
           byrow = TRUE)
  
  # Se realiza la multiplicación de personas por su probabilidad de muerte
  matriz.final <- as.vector(num.personas) * as.matrix(matriz.prob)
  
  # Se crea un dataframe con la cantidad de personas restantes por año, para esto se sumarán las columnas de la matriz anterior
  df.resultado <-
    data.frame(anno = c(2023:(2091 - min(edades))),
               # 2024 + 65 + 2 - min(edades)
               trabajadores = colSums(matriz.final))
  
  # Se devolverá una lista, primero tendrá el resultado en DataFrame y posteriormente tendrá la matriz que indica cuántas personas se pensionarion cada año
  lista.res <- list(df.resultado, matriz.final)
  
  return(lista.res)
}
```

Se guardan los empleados activos fallecidos durante cada año (se comprueba que son los valores correctos al sumar los valores de la segunda columna del DataFrame de las funciones de empleados activos).

```{r act_muertos}
# Hombres activos fallecidos
activos.fallecidosh <- def.activos(empleados, qx.hombres, "M")

# Mujeres activas fallecidas
activos.fallecidosm <- def.activos(empleados, qx.mujeres, "F")
```

### Proyección demográfica de pensionados

Primeramente se determinarán los pensionados que entran cada año para cada sexo, usando lo hecho en el punto a).

```{r pensionados_por_anno}

# Se extraen las matrices de sobrevivientes por edad para cada sexo
matriz.hombres <- activos.vivosh[[2]]
matriz.mujeres <- activos.vivosm[[2]]

# Función para obtener las entradas de una matriz que tengan a su derecha una entrada igual a 0 (en nuestro contexto, las personas pensionadas)
personas.pensionadas <- function(matriz) {
  
  copia = copy(matriz)
  
  # Se encuentran las posiciones donde el valor a la derecha es igual a 0
  posiciones <- which(copia[, -ncol(copia)] != 0 & copia[, -1] == 0, arr.ind = TRUE)
  
  # Luego se extraen los valores de la matriz en esas posiciones
  valores <- copia[posiciones]
  
  return(valores)
  
}

# Se crean los años donde entran pensionados
anno <- c(2024:2068)

# Se extraen los pensionados hombres usando la función anterior
pensionados <- c(personas.pensionadas(matriz.hombres))

# Se crea el dataframe de pensionados hombres que entran por año
df.pensionadosh <- data.frame(anno = anno, pensionados = pensionados)

# Se extraen las pensionadas mujeres usando la función anterior
pensionados <- c(personas.pensionadas(matriz.mujeres))

# Se crea el dataframe de pensionadas mujeres que entran por año
df.pensionadosm <- data.frame(anno = anno, pensionados = pensionados)

```

Posteriormente se crea la función para determinar los pensionados que continúan vivos cada año por sexo.

```{r fun_pensionados_vivos}

# Función que recibe el DataFrame de los pensionados por sexo (df.pensionados) y el DataFrame de probabilidades de muertes por sexo (df.muertes).

# Devuelve un DataFrame con la cantidad de pensionados vivos que sigue viva cada año.

pob.pensionados <- function(df.pensionados, df.muertes){
  
  # Se obtienen las probabilidades de muerte para las edades de 65 en adelante y del año 2024 en adelante
  matriz.prob <- as.matrix(df.muertes[66:nrow(df.muertes), 26:ncol(df.muertes)])
  
  # Se crea un vector que contendrá la cantidad de pensionados que siguen vivos cada año
  pensionados <- c()
  
  # Los años de interés para el proyecto
  anno <- c(2024:2119)
  
  for(i in 1:96){
    
    lista.pensionados <- list()
    
    if((i - 51) > 0){
    
      for(j in (i-50):i){
        
        if(j <= 45){
          
          probabilidad <- prod(sapply(0:(i-j-1), function(k) (1 - matriz.prob[1+k, j+k])))
        
          lista.pensionados <- append(lista.pensionados, df.pensionados$pensionados[j] * probabilidad)
        
        } # fin if
          
      } # fin for j
      
    } else{
      
      for(j in 1:i){
        
        if(j <= 45){
          
          if(j == i){
            
            probabilidad <- 1
            
          } else{
        
            probabilidad <- prod(sapply(0:(i-j-1), function(k) (1 - matriz.prob[1+k, j+k])))
            
          } # fin if-else
          
          lista.pensionados <- append(lista.pensionados, df.pensionados$pensionados[j] * probabilidad)
        
        } # fin if
        
      } # fin for j
      
    } # fin if-else
    
    pensionados <- c(pensionados, sum(unlist(lista.pensionados)))
    
  } # fin for i
  
  # Se crea el dataframe con los años y los pensionados vivos y se devuelve
  df.final <- data.frame(anno = anno, pensionados = pensionados)
  
  return(df.final)
  
}

```

Se guardan las proyecciones demográficas de pensionados para hombres y mujeres.

```{r proyeccion_pensionados}

# Hombres pensionados vivos
pensionados.vivosh <- pob.pensionados(df.pensionadosh, qx.hombres)

# Mujeres pensionadas vivas
pensionados.vivosm <- pob.pensionados(df.pensionadosm, qx.mujeres)

```

### Proyección demográfica de defunciones de pensionados

Ahora se va a crear la función de muertes de pensionados para cada año.

```{r fun_pensionados_muertos}

# Funcion que recibe el DataFrame de los pensionados por sexo (df.pensionados) y el DataFrame de probabilidades de muertes por sexo (df.muertes).

# Devuelve un DataFrame con los pensionados fallecidos por cada año.

def.pensionados <- function(df.pensionados, df.muertes){
  
  # Se obtienen las probabilidades de muerte para las edades de 65 en adelante y del año 2024 en adelante
  matriz.prob <- as.matrix(df.muertes[66:nrow(df.muertes), 26:ncol(df.muertes)])
  
  # Se crea un vector vacío que contendrá la cantidad de pensionados fallecidos cada año
  pensionados <- c()
  
  # Los años de interés para el proyecto
  anno <- c(2024:2119)
  
  for(i in 1:96){
    
    lista.pensionados <- list()
    
    if((i - 51) > 0){
    
      for(j in (i-50):(i-1)){
        
        if(j <= 45){
          
          probabilidad.sobrevivir <- prod(sapply(0:(i-j-1), function(k) (1 - matriz.prob[1+k, j+k])))
          
          probabilidad.muerte <- matriz.prob[i-j+1, i]
        
          lista.pensionados <- append(lista.pensionados, df.pensionados$pensionados[j] * probabilidad.sobrevivir * probabilidad.muerte)
        
        } # fin if
          
      } # fin for j
      
    } else{
      
      contador <- 1
      
      for(j in 1:i){
        
        if(contador <= 45){
          
          if(j == i){
        
            probabilidad.sobrevivencia <- 1
          
            probabilidad.muerte <- matriz.prob[1, j]
          
          } else{
            
            probabilidad.sobrevivencia <- prod(sapply(0:(i-j-1), function(k) (1 - matriz.prob[1+k, j+k])))
            
            probabilidad.muerte <- matriz.prob[i-j+1, i]
            
          } # fin if-else
          
          lista.pensionados <- append(lista.pensionados, df.pensionados$pensionados[contador] * probabilidad.sobrevivencia * probabilidad.muerte)
          
          contador <- contador + 1
        
        } # fin if
        
      } # fin for j
      
    } # fin if-else
    
    pensionados <- c(pensionados, sum(unlist(lista.pensionados)))
    
  } # fin for i
  
  df.final <- data.frame(anno = anno, pensionados = pensionados)
  
  return(df.final)
  
}

```

Ahora se guardan los pensionados fallecidos durante cada año.

```{r pensionados_muertos}

# Hombres pensionados fallecidos
pensionados.fallecidosh <- def.pensionados(df.pensionadosh, qx.hombres)

# Mujeres pensionadas fallecidas
pensionados.fallecidosm <- def.pensionados(df.pensionadosm, qx.mujeres)

```

### Proyección financiera de los pagos de beneficios de muerte de empleados activos

Como primer paso, se extraen los dataframes necesarios.

```{r}
df.activos.fallecidosm <- as.data.frame(activos.fallecidosm[[1]])
df.activos.fallecidosh <- as.data.frame(activos.fallecidosh[[1]])

#eliminar 2023 con 0 muertes
df.activos.fallecidosh <- df.activos.fallecidosh[-1, ]
df.activos.fallecidosm <- df.activos.fallecidosm[-1, ]

```

Luego, se crea la funcion necesaria, recibe un dataframe para el calculo y devuelve otro con los resutados. Los años son los mismos, y para el cálculo se extrae la cantidad de muertes por año de empleados activos.

```{r}

ben.muerte.activos <- function(df){
  df.ben.muerte.activos = data.frame(
    año <- df[, 1],
    beneficios <- NA
  )
  vec_beneficios = c()
  for (i in 1:47) {
    beneficio <- (5000000)*((1 + 0.03)^i) * (df[i, 2]) 
    vec_beneficios <- c(vec_beneficios, beneficio)
  }
  df.ben.muerte.activos$beneficios <- vec_beneficios
  return(df.ben.muerte.activos)
}

```

Se guardan y se limpian los resultados tanto para hombres como para mujeres

```{r}
ben.muerte.act.h <- ben.muerte.activos(df.activos.fallecidosh)
ben.muerte.act.m <- ben.muerte.activos(df.activos.fallecidosm)

ben.muerte.act.h <- ben.muerte.act.h[, -2]
ben.muerte.act.m <- ben.muerte.act.m[, -2]

names(ben.muerte.act.h)[names(ben.muerte.act.h) == "año....df...1."] <- "año"
names(ben.muerte.act.m)[names(ben.muerte.act.m) == "año....df...1."] <- "año"


```

### Proyección financiera de los pagos de anualidades

La función recibe un df (pensionados/as vivos/as) como parámetro y devuelve uno con las anualidades calculadas. Los años son los mismos. La anualidad se calcula como los 300 000 por la inflación por los pensionados de ese año por 13 (los pagos en los 12 meses más el aguinaldo).  

```{r}
anualidades <- function(df){
  df.anualidades <- data.frame(
    año <- df[, 1],
    anualidades <- NA
  )
  vec.anualidades <- c()
  for (i in 1:length(pensionados.vivosh[,1])){
    anualidad <- 13*(300000*(1+0.03)^i)*(df[i, 2])
    vec.anualidades <- c(vec.anualidades, anualidad)
  }
  df.anualidades$anualidades <- vec.anualidades
  return(df.anualidades)
}
```

Se guardan y se limpian los resultados tanto para hombres como para mujeres

```{r}
anualidades.h <- anualidades(pensionados.vivosh)
anualidades.m <- anualidades(pensionados.vivosm)

anualidades.h <- anualidades.h[, -2]
anualidades.m <- anualidades.m[, -2]

names(anualidades.h)[names(anualidades.h) == "año....df...1."] <- "año"
names(anualidades.m)[names(anualidades.m) == "año....df...1."] <- "año"

```

### Proyección financiera de los pagos de beneficios de muerte de pensionados

Se procede a realizar la funcion que calcula la proyeccion de los beneficios de los pesionados que mueren

```{r benef.pensionados.muertos}

#Funcion que recibe un df con los pensionados que mueren por ano

#devuelve un df con el monto que se debe tener para poder cubrir esta cantidad de muertes cada anno
def.proyeccion.finac.pen <- function(df.pensionados.fallecidos) {
  
  M <- 1e6
  j <- 0.03
  
  #Se inicializa una lista del tamano de numero de filas del df para asi ir guardando los montos de todos los annos
  costos <- numeric(nrow(df.pensionados.fallecidos))
  
  #el for recorre cada ano y cada cantidad de muertos por anno, considera la inflacion
  for (i in 1:nrow(df.pensionados.fallecidos)) {
    inflacion <- (1 + j)^(i - 1)
    
    #Clacula el monto ajustao por inflacion
    costos[i] <- df.pensionados.fallecidos$pensionados[i] * M * inflacion
  }
  
  # Crear un DataFrame con los resultados
  df_costos <- data.frame(
    anno = df.pensionados.fallecidos$anno,
    costo = costos
  )
  
  return(df_costos)
}

```

Se aplica la funcion para los df ya establecidos tanto de hombres como mujeres

```{r costo_pensionados}
# Aplicar la función a los pensionados fallecidos hombres y mujeres
costos.pensionados.fallecidosh <- def.proyeccion.finac.pen(pensionados.fallecidosh)
costos.pensionados.fallecidosm <- def.proyeccion.finac.pen(pensionados.fallecidosm)

```

### Calculo de prima anual

se crea la funcion que calcula primas anuales
```{r}

#funcion para calcular kpx
calcular_kpx <- function(x,k,tabla){
  
  if (k > 0){
  
    kpx <- prod(sapply(0:(k-1), function(i) 1-tabla[[x+i+1, 26+i]]))
  }
  else {
    kpx <- 1
  }
  return(kpx)
}
```

```{r}
calcular_primas <- function(edad, tabla_mort) {
  tasa_j_eq <- ((1.03) * (1.04)) - 1
  v <- (1 + 0.03) / (1 + tasa_j_eq)
  
  ben_muerte_act <- 5000000 * sum(sapply(0:(64 - edad), function(i) {
    v ^ (i + 1) * calcular_kpx(edad, i, tabla_mort) * tabla_mort[[edad + i + 1, 26 + i]]
  }))
  
  ben_muerte_pens <-
    v ^ (65 - edad) * calcular_kpx(edad, (65 - edad), tabla_mort) * 1000000 * sum(sapply((0:50), function(k)
      v ^ (k + 1) * calcular_kpx(edad, k, tabla_mort) * tabla_mort[[65 + k + 1, 26 + 65 + k]]))
  
  ben_anualidades <-
    v ^ (65 - edad) * calcular_kpx(edad, 65 - edad, tabla_mort) * 13 * 300000 * sum(sapply((0:50), function(m)
      v ^ (m + 1) * calcular_kpx(65, m, tabla_mort)))
  
  denominador <-
    sum(sapply((1:(66 - edad)), function(r)
      v ^ (r) * calcular_kpx(edad, r, tabla_mort)))
  
  primas <-
    c((ben_muerte_act + ben_muerte_pens + ben_anualidades) / denominador,
      primas)
  vp <- (ben_muerte_act + ben_muerte_pens + ben_anualidades)
  anualidad <- denominador
  
  return(list(
    primas = primas,
    vp = vp,
    anualidad = anualidad
  ))
}

```

para almacenar los datos de las primas, se usa como base el dataframe empleados. 
```{r}
datos.hombres <- empleados[empleados$sexo == "M", ]

datos.hombres <- datos.hombres[, -c(1, 2, 4, 5)] 
datos.hombres <- datos.hombres[!duplicated(datos.hombres$edad), ]

datos.mujeres <- empleados[empleados$sexo == "F", ]

datos.mujeres <- datos.mujeres[, -c(1, 2, 4, 5)] 
datos.mujeres <- datos.mujeres[!duplicated(datos.mujeres$edad), ]
```

Se calculan las primas para hombres y mujeres, y se guardan en el dataframe de datos de cada uno.

```{r}
resultados.hombres <- lapply(1:45, function(p) calcular_primas(p, qx.hombres))
primas.hombres <- sapply(resultados.hombres, function(res) res$prima)
vp.hombres <- sapply(resultados.hombres, function(res) res$vp)
anualidad.hombres <- sapply(resultados.hombres, function(res) res$anualidad)

resultados.mujeres <- lapply(1:45, function(l) calcular_primas(l, qx.mujeres))
primas.mujeres <- sapply(resultados.mujeres, function(res) res$prima)
vp.mujeres <- sapply(resultados.mujeres, function(res) res$vp)
anualidad.mujeres <- sapply(resultados.mujeres, function(res) res$anualidad)
```



```{r}
datos.hombres[["primas"]] <- primas.hombres
datos.hombres[["vp"]] <- vp.hombres
datos.hombres[["anualidad"]] <- anualidad.hombres

datos.mujeres[["primas"]] <- primas.mujeres
datos.mujeres[["vp"]] <- vp.mujeres
datos.mujeres[["anualidad"]] <- anualidad.mujeres
```

```{r}
prima_nivelada <- (sum(datos.hombres$vp) + sum(datos.mujeres$vp)) / (sum(datos.hombres$anualidad) + sum(datos.hombres$anualidad))
print(paste("La prima media nivelada es:", round(prima_nivelada, 2)))
```

### Metodos de reducciones de primas en un 10%

En el primer método se va a reducir el monto de la pension por aproximación manual, al reducir los pagos mensuales, los costos mensuales se disminuyen, lo cual resulta beneficioso para la empresa, ya que necesitaria menos fondos para cubrir sus gastos, sin embargo, trae efectos negativos en los empleados, principalmente debido a que el monto de la pension se va a reducir.

```{r}
calcular_primas_metodo1 <- function(edad, tabla_mort){
  tasa_j_eq <- ((1.03)*(1.04)) -1
  v <- (1+0.03)/(1+tasa_j_eq)
  primas <- c()
  
ben_muerte_act <- 5000000 * sum(sapply(0:(64 - edad), function(i) {
  v^(i + 1) * calcular_kpx(edad, i, tabla_mort) * tabla_mort[[edad + i + 1, 26 + i]]
}))
  
  ben_muerte_pens <- v^(65-edad)*calcular_kpx(edad, 65-edad, tabla_mort)*1000000*sum(sapply((0:50), function(k) v^(k+1) * calcular_kpx(edad, k, tabla_mort)*tabla_mort[[65 + k + 1, 26 + 65 + k]]))
  
  ben_anualidades <- v^(65-edad)*calcular_kpx(edad, 65-edad, tabla_mort)*13*267000 * sum(sapply((0:50), function(m) v^(m+1)* calcular_kpx(65, m, tabla_mort)))
  
  denominador <- sum(sapply((1:(66-edad)), function(r) v^(r) * calcular_kpx(edad, r, tabla_mort)))
  
  primas <- c((ben_muerte_act + ben_muerte_pens + ben_anualidades)/denominador, primas)
  
  return(primas)
}
```

```{r}
primas.hombres_metodo1 <- sapply((1:45), function(p) calcular_primas_metodo1(p, qx.hombres))
primas.mujeres_metodo1 <- sapply((1:45), function(l) calcular_primas_metodo1(l, qx.mujeres))
```

```{r}
datos.hombres[["primas_metodo1"]] <- primas.hombres_metodo1
datos.mujeres[["primas_metodo1"]] <- primas.mujeres_metodo1
```

El segundo metodo consiste en que ya las personas no van a poder jubilarse hasta la edad de 66, esto resulta en menos pagos de pensiones, y a su vez que los empleados van a aportar por mas años al fondo de pensiones; de igual forma el valor presente disminuye, por otro lado, los empleados podran acumular beneficios por mas tiempo.

```{r}
calcular_primas_metodo2 <- function(edad, tabla_mort){
  tasa_j_eq <- ((1.03)*(1.04)) -1
  v <- (1+0.03)/(1+tasa_j_eq)
  primas <- c()
  
ben_muerte_act <- 5000000 * sum(sapply(0:(66 - edad), function(i) {
  v^(i + 1) * calcular_kpx(edad, i, tabla_mort) * tabla_mort[[edad + i + 1, 26 + i]]
}))
  
  ben_muerte_pens <- v^(67-edad)*calcular_kpx(edad, 67-edad, tabla_mort)*1000000*sum(sapply((0:48), function(k) v^(k+1) * calcular_kpx(edad, k, tabla_mort)*tabla_mort[[67 + k + 1, 26 + 67 + k]]))
  
  ben_anualidades <- v^(67-edad)*calcular_kpx(edad, 67-edad, tabla_mort)*13*300000 * sum(sapply((0:48), function(m) v^(m+1)* calcular_kpx(67, m, tabla_mort)))
  
  denominador <- sum(sapply((1:(68-edad)), function(r) v^(r) * calcular_kpx(edad, r, tabla_mort)))
  
  primas <- c((ben_muerte_act + ben_muerte_pens + ben_anualidades)/denominador, primas)
  
  return(primas)
}
```

```{r}
primas.hombres_metodo2 <- sapply((1:45), function(p) calcular_primas_metodo2(p, qx.hombres))
primas.mujeres_metodo2 <- sapply((1:45), function(l) calcular_primas_metodo2(l, qx.mujeres))
```

```{r}
datos.hombres[["primas_metodo2"]] <- primas.hombres_metodo2
datos.mujeres[["primas_metodo12"]] <- primas.mujeres_metodo2
```


## Modelo estocástico

Inicialmente, se extraen las probabilidades de supervivencia que se usarán para el modelo.

```{r prob_sobrevivencia}
# Probabilidades de sobrevivencia
densidad.h <- 1 - sapply(22:116, function(x) qx.hombres[[x, 4 + x]])
densidad.m <- 1 - sapply(22:116, function(x) qx.mujeres[[x, 4 + x]])
```

Se creará una función para identificar el primer *False* de cada fila de una matriz.

```{r fun_false}
fila.muerte <- function(fila){
  # Primer índice que es falso
  fila[(which(!fila)[1] + 1):length(fila)] <- FALSE
  return(fila)
}
```

Posteriormente, se procede a realizar manualmente la primera iteración del modelo, pues la función recibirá como parámetro la primera prima calculada.

```{r primera_iteracion}
ini <- Sys.time()
# Lista para resultados
lista.primash <- list()
lista.primasm <- list()

# Tasa equivalente
j <- ((1.04) * (1.03)) - 1

# Todas las probabilidades de muerte, de hombres, de 21 hasta 65
prob.muerteh <- sapply(1:45, function(i) sapply(((21 + i)):116, function(k) qx.hombres[[k, 25 + k]]))

# Matriz de probabilidades de supervivencia, de hombres, desde edad inicial 21 hasta edad inicial 65, cada fila es una persona de edad 21, 22, 23, ...
matriz.probh <- (1 - t(as.matrix(sapply((1:length(prob.muerteh)), function(l) c(prob.muerteh[[l]], rep(1, (length(prob.muerteh[[1]]) - length(prob.muerteh[[l]]) + 1)))))))

# Todas las probabilidades de muerte, de mujeres, de 21 hasta 65
prob.muertem <- sapply(1:45, function(i) sapply(((21 + i)):116, function(k) qx.mujeres[[k, 25 + k]]))

# Matriz de probabilidades de supervivencia, de mujeres, desde edad inicial 21 hasta edad inicial 65, cada fila es una persona de edad 21, 22, 23, ...
matriz.probm <- (1 - t(as.matrix(sapply((1:length(prob.muertem)), function(l) c(prob.muertem[[l]], rep(1, (length(prob.muertem[[1]]) - length(prob.muertem[[l]]) + 1)))))))

# Se eliminan las columnas innecesarias
matriz.probh <- matriz.probh[, 1:(ncol(matriz.probh) - 1)]
matriz.probm <- matriz.probm[, 1:(ncol(matriz.probm) - 1)]

# Nombres de filas y columnas
colnames(matriz.probh) <- c(2024: (2024 + 115 - 21))
colnames(matriz.probm) <- c(2024: (2024 + 115 - 21))
rownames(matriz.probh) <- c(21:65)
rownames(matriz.probm) <- c(21:65)

# El número de filas y columnas es fijo, entonces se guardará para que no se calcule en cada iteración después
colmat <- ncol(matriz.probh)
filmat <- nrow(matriz.probm)

# Creamos las matrices de números aleatorios
matriz.rndh <- matrix(data = pnorm(rnorm(colmat * filmat, mean(densidad.h), sd = sd(densidad.h)), mean = mean(densidad.h), sd = sd(densidad.h)), nrow = filmat, ncol = colmat)

matriz.rndm <- matrix(data = pnorm(rnorm(colmat * filmat, mean(densidad.m), sd = sd(densidad.m)), mean = mean(densidad.m), sd = sd(densidad.m)), nrow = filmat, colmat)

# Comparación de matrices
matriz.rndh <- matriz.rndh < matriz.probh
matriz.rndm <- matriz.rndm < matriz.probm

# Se agregan los falsos después del primer falso de la matriz
matriz.rndh <- t(apply(matriz.rndh, 1, fila.muerte))
matriz.rndm <- t(apply(matriz.rndm, 1, fila.muerte))

# Índice del primer falso
idh <- sapply(1:filmat, function(m) which(!matriz.rndh[m, ])[1]) - 1
idm <- sapply(1:filmat, function(m) which(!matriz.rndm[m, ])[1]) - 1

# Anualidades
anh <- sapply(1:filmat, function(n) sum((1 + j) ^ -(0:(min(idh[n], (65 - 20 - n))))))
anm <- sapply(1:filmat, function(n) sum((1 + j) ^ -(0:(min(idh[n], (65 - 20 - n))))))

# Rango de años de cada persona desde que llega a 65 años hasta que fallece
annosh.65 <- sapply(21:65, function(o) c((65 - o + 1):(idh[[o - 20]] + 1)))
annosm.65 <- sapply(21:65, function(o) c((65 - o + 1):(idm[[o - 20]] + 1)))

# Beneficios para trabajadores y pensionados
benh <- sapply(1:length(annosh.65), function(p) (ifelse(idh + c(21:65) < 65, 5000000 * ((1 + j) ^ -(idh + 1)), sum(300000 * 13 * (1 + j) ^ -annosh.65[[p]]) + 1000000 * ((1 + j) ^ -(idh + 1))))[p])

benm <- sapply(1:length(annosm.65), function(p) (ifelse(idm + c(21:65) < 65, 5000000 * ((1 + j) ^ -(idm + 1)), sum(300000 * 13 * (1 + j) ^ -annosm.65[[p]]) + 1000000 * ((1 + j) ^ -(idm + 1))))[p])

# Guardamos el resultado
lista.primash[[1]] <- (benh / anh)
lista.primasm[[1]] <- (benm / anm)

fin <- Sys.time()
print(fin - ini)
```

Posteriormente, se realiza la función que se encarga de las demás iteraciones del modelo estocástico.

```{r siguientes_iteraciones}
modelo.estocastico <- function(matriz.prob, prom.primas, densidad, lista.primas){
  while (abs(prom.primas - mean(unlist(lista.primas))) > 0.001) {
    # Creamos la matriz de números aleatorios
  matriz.rnd <- matrix(data = pnorm(rnorm(colmat * filmat, mean(densidad), sd = sd(densidad)), mean = mean(densidad), sd = sd(densidad)), nrow = filmat, ncol = colmat)
  
  # Comparación de matrices
  matriz.rnd <- matriz.rnd < matriz.prob
  
  # Se agregan los falsos después del primer falso de la matriz
  matriz.rnd <- t(apply(matriz.rnd, 1, fila.muerte))
  
  # Índice del primer falso
  id <- sapply(1:filmat, function(m) which(!matriz.rnd[m, ])[1]) - 1
  
  # Anualidad
  an <- sapply(1:filmat, function(n) sum((1 + j) ^ -(0:id[n])))
  
  # Rango de años de cada persona desde que llega a 65 años hasta que fallece
  annos.65 <- sapply(21:65, function(o) c((65 - o + 1):(id[[o - 20]] + 1)))
  
  # Beneficios para trabajadores y pensionados
  ben <- sapply(1:length(annos.65), function(p) (ifelse(id + c(21:65) < 65, 5000000 * ((1 + j) ^ -(id + 1)), sum(300000 * 13 * (1 + j) ^ -annos.65[[p]]) + 1000000 * ((1 + j) ^ -(id + 1))))[p])
  
  # Actualizamos el promedio correspondiente
  prom.primas <- mean(unlist(lista.primas))
  
  # Primas
  lista.primas <- append(lista.primas, list(ben / an))
  }
  
  # Se devuelven las primas de cada iteración
  return(lista.primas)
  }
```

Probamos el modelo para cada género.

```{r modelo}
ini <- Sys.time()
prueba <- modelo.estocastico(matriz.probh, 0, densidad.h, lista.primash)
fin <- Sys.time()
print(fin - ini)
```

